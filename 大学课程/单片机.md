## 结构原理

- 乘法指令中，低字节放在A中，高字节放在B中。若乘积大于0FFH，则OV置1
- 除法指令中， A存放被除数 ，B存放除数，商存放与A，B中存放余数

- PSW

| 位名称 |  CY   |  AC  |    F0    |     RS1      |     RS0      |  OV  |  -   |   P   |
| ------ | :---: | :--: | :------: | :----------: | :----------: | :--: | :--: | :---: |
| 位意义 | 进/借 | 辅进 | 用户标定 | 寄存器组选择 | 寄存器组选择 | 溢出 | 保留 | 奇/偶 |
- P

  每条指令执行完后，如果A中奇数1个，则置P=1;否则P=0

- 数据指针DPTR(83H, 82H)

  高字节为DPH(83H), 低字节位DPL(82H)

- fosc=0~24MHz
- 时钟信号周期=机器状态周期=2*振荡周期
- 一个机器周期包含12个振荡周期，分为6个状态

### 复位操作的主要功能

- PC复位0000H
- 在SFR中， **除了** 端口锁存器，堆栈指针SP和串行口的SBUF外，其余寄存器全部 **清零** 
- 内部RAM状态 **不受** 复位的影响
- SP复位为07H
- P0~P3复位后为FFH

## 指令系统

### 寻址方式
#### 7种寻址方式
##### 寄存器寻址
```
MOV A, R0
MOV P1, A
ADD A, R0
```
##### 直接寻址
```
MOV A, 40H
MOV A, P1
```
##### 立即数寻址
```
MOV A, #3AH
```
##### 寄存器间接寻址
- R0,R1为间接寻址寄存器，可寻址内部低128位字节单元内容
- DPTR作为外部间接寻址寄存器
```
MOV A, @R0
```
##### 变址寻址
- 只能访问程序存储器(ROM)，范围为64K
- 不能写入（只读），多用于查表
```
MOVC A, @A+DPTR
```
##### 相对寻址
- 只出现在相对转移指令

- ***目的地址=源地址+2（相对转移指令字节数）
+rel***
##### 位寻址
- 对20H~2FH的128位直接使用位地址
- 对于SFR可以使用寄存器名字加位数表示，如：PSW.3
```
CLR bit
```

### 指令系统
#### 数据传送指令

-  以累加器A为目的操作数的指令
```
  MOV A, Rn
  MOV A, direct
  MOV A, @Ri
  MOV A, #data
```


- 以寄存器Rn为目的操作数的指令
```
MOV Rn, A
MOV Rn, direct
MOV Rn, #data
```

#### 控制转移类指令
##### 无条件跳转指令
  - 短转移指令(2K)
```
AJMP addr11
```
  - 长转移指令(64K)
```
LJMP addr16
```

  - 相对转移指令(-128~+128字节)
```
SJMP rel
```
  - 间接转移指令(+256字节)
```
JMP @A+DPTR
```

##### 子程序跳转指令

- 堆栈先存低八位，后压入高八位

- 短调用
```
ACALL addr11
```

- 长调用
```
LCALL addr16
```


## 伪指令

1. EQU
  -  `字符名称：EQU 项（数或者汇编符号）` 
  - 把“项”赋值给”字符名称”
2. DATA
  -  `字符名称 DATA 表达式` 
  - 与EQU类似，但有区别
    1. DAT定义的字符名可以后定义先使用
    2. 只能把数据赋给字符名
    3. 可以把一个表达式的值赋给字符名称
  - 常用来定义数据地址
3. DB
  -  `DB [项或项表]` 
  - 从当前ROM地址开始， **保留** 一字节或字节串的存储 **单元** 并 **存入** DB后的 **数据** 
4. DW
  -  `DW 16位数据项或者项表` 
  - 高8位先存放，低8位后存放
5. DS
  -  `DS 表达式` 
  - 保留表达式的值所规定的存储单元
6. BIT
  -  `字符名 BIT 位地址` 
  - 把BIT之后的地址值赋给字符名

## 中断寄存器

- IE

| EA   | -    | -    | ES   | ET1  | EX1  | ET0 | EX0 |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|      |      |      |      |      |      |  |  |




- IP

| -    | -    | -    | PS   | PT1  | PX1  | PT0  | PX0  |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |



-  **TH1/TL1&TH0/TL0** 
  - 定时器1计数器高/低字节
  - 定时器0计数器高/低字节
- TCON

| TF1 | TR1 | TF0 | TR0 | IE1 | IT1 | IE0 | IT0 |
|:----:|:----:|:----:|:---:|:--:|:----:|:---:|:----:|
||||||||

- TMOD

| GATE1 | C/T | M1 | M0 | GATE0 | C/T | M1 | M0 |
|:----:|:----:|:----:|:---:|:--:|:----:|:---:|:----:|
||||||||

- SCON

| SM0  | SM1 | SM2 | REN | TB8 | RB8 | T1 | R1   |
|:---:|:----:|:----:|:---:|:--:|:---:|:---:|:----:|
||||||||

>   - SM0&SM1：工作方式选择
  - SM2：多机通信（1：允许）
  - REN：接收控制（1：允许）
  - TB8/RB8：发送/接收数据第9位
  - T1：发送中断标志
  - R1：接收中断标志

- PCON(SMOD)
  - 波特率倍增（模式1，2，3），只有最高位有用

## 定时器初值计算
- 模式1

```
t = ( 2^16 - 初值 ) * 振荡周期（MHz）*12
```

- 模式2
```
t = ( 2^8 - 初值 ) * 振荡周期（MHz）*12
```

## 串行口通信波特率

- 方式0

```
波特率≌f/12
```
- 方式2

```
波特率≌(2^SMOD/64)*f
```

- 方式1&3

```
X≌256 - ( f*(SMOD+1) )/384*波特率
注意：f=11.0592
```
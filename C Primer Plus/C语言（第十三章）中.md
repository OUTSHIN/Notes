#### 标准I/O的机理
- 由于stdio.h系列的所有输入函数都是用相同的缓冲区，所以调用任何一个函数都将从上一次函数停止调用的位置开始
- 当输入函数发现读完缓冲区所有字符，会请求把下一个缓冲区大小的数据块从文件拷贝到缓冲区中
- 函数在读取缓冲区中的最后一个字符后，把结尾指示器设置为真。于是下一次被调用的函数将返回EOF

#### 其他标准I/O 函数
#####  `int ungetc(int c, FILE *fp)` 
> 把c指定的字符放回输入流中\n
> 假设要读取冒号前所有字符（不包括冒号），可以用getchar()读取到冒号，然后用ungetc()把冒号放回到输入流中

- 原型为int（由于有EOF）
- 标准保证每次只会放回一个字符
- 如果多个字符放回输入流，下次输入函数读取到的顺序与放回顺序相反

#####  `int fflush(FILE *fp);` 
> 引起**输出缓冲区**中所有的未写入数据发送到fp指定的输入文件（刷新缓冲区）

- 如果fp是空指针，所有缓冲区都被刷新
- 在输入流使用的效果是未定义的
- 只要最后一次操作不是输入操作，就可以用该函数来更新流

#####  `int setvbuf(FILE *restrict fp, char * restrict buf, int mode, size_t size);` 
> 创建一个供标准I/O函数替换使用的缓冲区

- 在打开文件后未对流进行其他操作前调用该函数
- fp指向待处理的流，buf指向待使用的存储区。如果buf值不是NULL，则必须创建一个缓冲区
- NULL为buf的值，函数会自己分配缓冲区
- size告诉函数数组的大小
- mode：_IOFBF表示**完全缓冲**，_IOLBF表示**行缓冲**，_IONBF表示**无缓冲**
- 如果操作成功返回0，否则返回非0值
- 假设要存储一种数据对象，可以用该函数创建该数据对象字节数的倍数大小

##### 二进制I/O：fread()和fwrite()
> 为保证精度，存储数据时以程序所用的表示法把数据存储在文件，称***以二进制形式***存储数据（不存在数值到字符串转换的过程）

##### size_t fwrite()函数
```
size_t fwrite(const void * restritic ptr, size_t size, size_t  nmemb, FILE * restrict fp)
```
- 指针ptr是待写入数据块的地址
- size表示待写入数据块大小（字节为单位）
- nmemb表示待写入数据块的数量
- fp指定待写入的文件
- 成功时返回值为nmemb（返回成功写入项的数量），出现写入错误返回值会比nmemb小

##### size_t fread()函数
```
size_t fread(void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp)
```
- 与fwrite()类似
- ptr为待读取文件数据在内存中的存储位置（从fp读取存到ptr指向的位置）
- fp指向待读取文件
- 用于读取被fwrite()写入文件的数据
- 成功时返回值为nmemb（返成功回读取的数量），出现写入错误返回值会比nmemb小

##### int feof(FILE * fp)和int ferror(FILE *fp)函数
> 函数在遇到结尾或错误都会返回EOF，两函数用于区分

 - 当上一次输入调用检测到文件结尾时，feof()函数返回一个非0值，否则返回0
- 当读或写出现错误，ferror()返回一个非0值，否则返回0

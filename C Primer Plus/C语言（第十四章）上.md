### 结构和其他数据形式
#### 建立结构声明
> 描述一个结构的组织布局

```
struct book{
    char title[MAXTITLE];
    float value;
};
```
- 右括号后面的分号是必须的，表示结构体定义结束
- 可放在函数内部或外部。如果放在内部，只限于该函数内部使用
- 结构体标记名可选（本例的book）

#### 定义结构变量
```
struck book library;
/*创建了结构变量library*/
```
- struct book相当于一般声明的int或float。可以定义两个类型变量，甚至指向该结构类型的**指针**
- 对计算机而言
  ```
struck book library;
  ```
  ```
struct book{
    char title[MAXTITLE];
    float value;
} library ;
  ```
上面的声明是下面的声明的的简化
- 换言之声明结构的过程可以和定义结构变量的过程可以组合为一个步骤
  ```
struct {/*无结构标记*/
    char title[MAXTITLE];
    float value;
} library ;
  ```
  - 组合后的结构声明和结构变量定义不需要使用结构标记

##### 初始化结构
> 初始化一个结构变量与初始化数组语法类似

```
struct book library{"hello",1.3};
```
- 使用一对花括号中括起来的初始化列表进行初始化
- 循序应该相同
- 各项用逗号隔开
- 初始化静态存储期结构，初始化列表必须是常量表达式

##### 访问结构成员
> 使用结构成员运算符--点（.）访问结构中的成员

- .比&的优先级高

##### 结构的初始化器
> 结构的初始化器使用点运算符和成员名称（而不是方括号和下标）标识特定的元素

```
struct book library = { .value = 19.8 };
```
-可按照任意顺序使用指定初始化器
- 与数组类似，在指定初始化器后面的普通初始化器，为指定成员后面的成员提供初始值
- 对特定成员的**最后**一次赋值才是它实际获得的值

#### 结构数组
- 考虑栈内存的大小，以防止导致错误

##### 声明结构数组
```
struct book library [MAXBKS];
```
- library不是结构名，它是一个数组名，该数组每个元素都是struct book类型的结构变量（带下标的是结构名）

##### 标识结构数组的成员
> 采用单独访问的规则：在结构名后面加一个点运算符，再在点运算符后面写上成员名

```
library[0].value=2;
```

- library[0].title[4]表示这是library数组第1个结构变量中书名的第5个字符

#### 嵌套结构
> 在一个结构中包含另一个结构

```
struct names{
    char first[LEN];
    char last[LEN];
};  //第一个结构

struct guy{
    struct names handle;    //嵌套结构
    char favfood[LEN];
};
```
- 访问嵌套结构成员需要使用**两次**点运算符
  ```
printf("%s", fellow.handle.first);
  ```

  - 从左向右解释felliw.handle.first（(felliw.handle).first）
  - 也就是找到fellow，然后找到fellow的handle成员，再找到handle的first成员

#### 指向结构的指针
1. 更容易操作
2. 早期实现不能传递结构到函数，但可以传递指针
3. 更有效率
4. 一些用于表示数据的结构中包含指向其他结构的指针

```
struct names {
    char first[LEN];
    char last[LEN];
};

struct guy {
    struct names handle;
    char favfood[LEN];
    char job[LEN];
    float income;
};

struct guy fellow[2] = {
        {{ "Ewen", "Villard"},
            "grilled salmon",
            "personality coach",
            68112.00
        },
        {{"Rodney", "Swillbelly"},
            "tripe",
            "tabloid editor",
            432400.00
        }
    };
/*注意初始化*/
```

##### 声明和初始化结构指针
声明
```
struct guy *him;
```

初始化
```
him = &fellow[0];
```

- 结构体变量名**不是**结构的地址，需要**加&**运算符
- 指向结构体数组时指针**him++**会指向下一个结构

##### 用指针访问成员
Ⅰ. 使用 `->` 运算符
  -  如果 `him==&barney`, 那么`him=&barney`即是`him->inclome` 

Ⅱ.使用 `*`与 `&` 产生互逆运算
  -  `fellow[0].income == (*him) .income` 
  - 必须使用圆括号，因为.的优先级高

#### 向函数传递结构的信息
##### 传递结构成员
> 只要结构成员是一个具有单个值的数据类型（即，int，char，float...），便可以把它作为参数传递给接受该特定类型的函数

- 如果需要更改主调函数中成员的值就要传递成员地址

##### 传递结构的地址
```
double sum(const struct funds *);  
```
> sum函数使用指向funds结构的指针作为它的参数。然后用->运算符访问值

- 注意，必须使用&运算符来获取地址

##### 传递结构
```
double sum(struct funds moolah);  
```
- 调用函数时，程序根据funds模板创建名为moolah的自动结构变量，然后被初始化为实参副本

##### 其他结构特征
- C允许把一个结构赋值给另一个结构，但是数组不能这样做（即使成员是数组也可以）
- 函数不仅可以把结构体作为**参数**传递，还可以把结构作为**返回值**返回

##### 结构和结构指针的选择
- 指针：
  - 优点：
    1. 无论以前还是现在的C实现都能使用
    2. 执行起来很快
  - 缺点：
    1. 无法保护数据（不过const限定符解决了这个问题）
- 结构：
  - 优点
    1. 函数处理的是原始数据的副本，保护了原始数据
    2. 代码风格更清楚
  - 缺点：
    1. 较老版本无法处理这样的代码
    2. 传递结构浪费时间和存储空间
- 通常：
  - 追求效率用指针作为参数，如果需要防止原始数据以外修改，使用const限定符
  - 处理小型结构传递结构

##### 结构中的字符数组和字符指针
> 在结构中存储指向char数组的指针会导致潜在的安全问题

```
struct pnames {
    char * first;
}att;
```
- 这个结构本身只存储了一个地址占用了8个字节
- 在结构变量中的指针应该只用在程序中管理那些已分配和在别处分配的字符串
- att.first表示的地址**未经过初始化**可能导致严重问题

##### 结构、指针和malloc()
> 如果使用malloc()分配内存并使用指针存储该地址，那么在结构中使用指针处理字符串就比较合适

- 注意malloc()和free()的成对使用

##### 复合字面量和结构（C99）
> C99的复合字面量特征可以用于结构和数组。如果只需要一个***临时***结构值，复合字面量很好用

```
(struct book) {"The Idiot", "Fyodor", 6.28}
```
- 可以使用复合字面量创建一个数组作为函数的参数或赋值给另一个结构
- 如果函数接收地址，可以传递复合字面量的地址
- 复合字面量在所有函数外部，具有静态存储期
- 复合字面量在块中，具有自动存储期
- 可以在复合字面量中使用指定初始化器

##### 伸缩型数组成员（C99）
> 拥有这项特性的结构，其***最后一个***数组成员有以下特征\n1. 该数组不会立即存在\n2. 使用这个伸缩型数组成员可以编写合适的代码，就好像它确实存在并具有所需数目的元素一样

- 规则：
  1. 必须是结构最后一个成员
  2. 结构中必须至少有一个成员
  3. 伸缩数组的声明类似普通数组，只是**方括号是空的**
- 声明时不能使用，因为没有给这个数组分配空间（强制使用可能会导致出错）
- C99只是希望让你声明一个指向该结构的指针，然后用malloc()分配空间存储该结构常规内容和伸缩型数组
  ```
struct flex * pf;
pf=malloc(sizeof(struct flex)+5*sizeof(double));
/*分配空间后用指针来访问所创建的结构*/
pf->count    //count为结构中的元素
  ```
- 要求：
  1. 不能用结构进行赋值或拷贝（这样做只能拷贝除伸缩型数组成员以外的其他成员）
 `* pf2 = * pf1;    //不要这样做` 
  2. 不要以按值方式把这种结构传递给结构
  3. 不要使用带伸缩型数组成员的结构作为数组成员或另一个结构的成员

##### 匿名结构（C11）
> 匿名结构是一个没有名称的结构成员（在嵌套联合中更加有用）

```
struct names{
    char first[20];
    char last[20];
};
struct person{
    int id;
    struct names name;  //嵌套结构成员
};
struct person ted = {8277, {"ted", "ghdb"} };
```
这里，name成员是一个嵌套结构，可以用 `ted.name.first` 的表达式访问ted\n

在C11中，可以用嵌套的匿名成员定义person：

```
struct person{
    int id;
    struct {char first [20];char last [20]; };    //匿名结构
};
/*初始化方式相同*/
struct person ted = {8277, {"ted", "ghdb"} };
```
但是，在访问是简化了步骤，可以把first看做person的成员使用
 `put(ted.first);` 

##### 使用结构数组的函数
```
struct funds joines[2]=
{
    {8277, "ted", "ghdb" },
    {7277, "nsn", "nxnx" }
}
```

- 可以把数组名名作为数组中第一个结构的地址传给函数（ `joines==&joines[0]` ）
- 可以使用数组表示法访问数组中其他结构
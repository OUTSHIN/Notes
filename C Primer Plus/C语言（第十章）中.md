指针和数组
--- 
> 数组名是数组首元素的地址

```c
arr == &arr [0] ;    //成立
```
- 系统中地址按字节编址，指针加1指的是增加一个存储单元
- 一个较大对象的地址通常是该对象的第一个字节的地址
-  在指针前面用*运算符可以得到该指针所指向对象的值
```
dates + 2 == &dates [2]    //same address
*( dates + 2 ) == dates [2    //same value]
```
#### 注意

- 不要混淆*(dates +2 )和( *dates )+2 。*运算符优先级高于＋，所以* dates + 2相当于( *dates )+ 2
  ```c
*(dates+2)    //dates第三个元素的值
*dates+2    //dates第一个元素值加2
```
### 函数，数组和指针

>编写一个处理数组的函数，该函数返回数组所有元素的和，处理的名为marbles的int类型数组

```
total = sum (marbles);    //可能的函数调用
```

>数组命名是该数组首元素的地址，所以实际参数marbles是一个储存int类型的地址，应该把它赋值给指针形式参数

```c
int sum ( int * ar );    //对应的函数原型
```
##### 等价函数声明
```
int sum(int *ar , int n);
int sum(int * , int );
int sum(int ar[] ,int n );
int sum(int [] , int );
```
##### 等价函数定义
 ```
int sum(int *ar , int n )
{
    ...
}

int sum (int ar [] , int n)
{
    ...
}
```

### 使用指针形参
> 函数处理数组时必须知道何时开始，何时结束，除了用一个整形参数表示待处理元素还可以传递两个指针第1个指针指向开始处，第2个指针指向数组结束处

```c
#define SIZE  10
...
sum(marbles, marbles +SIZE );

int sum (int *start, int *end )
{
    while (start < end )  
/*end 指向的位置实际在数组最后一个元素后面*/
    {
        total += *start ++;
    }

}
```
- 一元运算符*和++的优先级相同，但是结合律是从右往左

### 指针表示法和数组表示法

- 对于C语言，ar[ i ]和*(ar + i )这两个表达式都是等价的。无论ar是数组名还是指针名表达式都没有问题
- 但是，只有当**ar是指针变量**时才能使用**ar ++**这样的表达式

### 指针操作
1. 赋值：
  可以把地址赋值指针，例如用数组名，带地址运算符（&）。但是注意地址应该和指针类型兼容（int 对 int*...）
2. 解引用： *运算符给出指针指向地址上储存的值
3. 取址：和所有变量一样，指针变量也有自己的地址和值
4. 指针与整数相加：可以使用+运算符把指针和整数想加。指针在前在后都可以（ptr+4或4+ptr）
5. 递增指针：指针移动到数组的下一个元素
6. 指针减一个整数：用-运算符减去一个整数。指针必须在前面（ptr-1）
7. 递减指针：前缀后缀运算符都可使用
8. 指针求差：计算两个指针的差值。差值的单位和数组类型单位相同，例如ptr2-ptr1（int类型）得2，意思是两个指针指向的两个元素直接相隔两个int。只要是两个指针都**指向相同的数组** (或数组后面第一个地址)都能保证**有效**
9. 比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的值

### 保护数组中的数据

> 如果函数的意图不是修改数组中的数据内容，那么在函数原型的函数定义中声明形式参数时应使用关键字const。
```c
int sum (const int ar [ ],int n );  //函数原型
```
以上代码告诉编译器不能修改ar指向的数组的内容

这样使用const并不是要求原数组是常量，而是函数在处理数组时将其视为常量

#### const的其他内容
>double rates [5]={1.11}

1. `const double  * pd = rates `该代码把pd指向的double类型的值声明为const，表明不能使用pd来改变它所指向的值。但是可以使用rates[0]=5来修改值
2. 指向const的指针通常用于函数形参中，表明该函数不会使用指针改变数据
3. 把**const数据**或**非const数据**的地址初始化为指向const的指针或为其赋值是合法的
4. 然而，**只能**把**非**const数据的地址赋给**普通指针**
5. 对函数形参使用const不仅可以保护数据，还能让函数处理const数组
6. 使用非const标识符修改const数据导致的结果是未定义的（p301）
7. 可以声明并初始化一个不能指向别处的指针
```c
double *const pc =rates ;   //pc 指向数组的开始
```
  - 可以用这种指针修改它所指向的值，但是它只能指向初始化时设置的地址
8. 创建指针时还可以使用const两次，该指针既不能更改所指向的地址，也不能修改指向地址的值
```c
const double *const pc =rates;
```
存储类别，链接和内存管理
-------

### 存储类别
#### 作用域（四种）
> 作用域描述程序中可访问标识符的区域

- *块作用域*
  - 定义在块中的变量具有***块作用域***，块作用域变量的可见范围是从定义处包含该定义的块的末尾
  - 函数的形式参数声明也具有块作用域，属于函数体这个块
  - 声明在内层块中的变量，其作用域仅限于该声明所在的块
  - C99标准允许在块中任意位置声明变量
  - 循环中的变量声明即便没有被花括号括起来，也算是块的一部分，一旦程序离开循环，就不能再访问
- *函数作用域*
  - 仅用于goto语句的标签
  - 即使一个标签首次出现在函数的内层块中，它的作用域也延伸至整个函数
  - goto只能在本函数内查找标签
- *函数原型作用域*
  - 用于函数原型中的形参名
  - 作用范围是从形参定义开始处到原型声明结束（意味着只关心类型名称通常无关紧要）
  - 只有在变长数组中，形参名才有用
  ```c
 void use_a_VLA ( int n, int m, ar [n] [m] );
  ```
  方括号中必须使用在函数原型中已声明的名称
- *文件作用域*
  > 变量的定义在函数的外面（main函数），具有文件作用域。

  - 具有文件作用域的变量，从它的定义处到该定义所在的文件的末尾均可见
  - 文件作用域变量也被称为**全局变量**

#### 链接
> C变量有3种链接属性：外部链接，内部链接，无链接。

- *无链接*
  - 具有块**作用域**，**函数作用域**，**函数原型作用域**的变量都是无链接变量。
  - 这些变量属于定义他们的块，函数或原型私有
- *外部链接*&*内部链接*
  - 具有文件作用域的变量可以是外部链接也可以是内部链接
  - 外部链接变量可以在多文件程序中使用
  - 内部链接只能在一个翻译单元中使用
  - ”内部链接的文件作用域“简称为”文件作用域”
  - “外部链接的文件作用域”简称为“全局作用域”或“程序作用域”
  - 使用存储类别说明符 `static` 的为**内部链接**

#### 存储期
> 描述了通过这些标识符访问的对象的生存期。有4种：静态存储期，线程存储期，自动存储期，动态分配存储期

- *静态存储期*
  - 文件作用域变量具有静态存储期（对于文件作用域变量static只表明了链接属性，而非存储期）
  - 在块中创建的带 `static` 的变量也具有静态存储期
    - 储存在静态内存中，从程序载入到结束期间都存在
    - 作用域只在定义的函数中，只有执行时该函数时才能用名称访问
    - 可以用函数提供该存储区的地址以便间接访问

- *线程存储期*
  > 线程存储期用于并发程序设计，程序执行可以被分为多个线程

  - 具有线程存储期的对象，从被声明时到线程结束一直存在
  - 以关键字 `_Thread_local` 声明一个对象时，每个线程都获得该变量的私有备份

- *自动存储期*
  - 块作用域变量通常都有自动存储期（可以有静态存储期，在块中声明，并加上static）
  - 程序**进入**定义这些变量的**块时**，为这些变量分配内存，当退出时，释放刚才为变量分配的内层
  - 变长数组不同，它的存储期从**声明处**到块的末尾，而不是从块的开始处到块的末尾

> **5种存储类别**

| 存储类别 | 存储期 | 作用域 | 链接 | 声明方式 |
|:----------:|:----------:|:----------:|:----------:|:----------:|
|       自动     |        自动    |       块     |    无        |     块内       |
|       寄存器     |      自动      |      块      |      无      |       块内，使用关键字register     |
|    静态外部链接        |      静态      |       文件     |   外部         |     所有函数外       |
|    静态内部链接        |      静态      |       文件     |    内部        |      所有函数外，使用static关键字      |
|      静态无链接      |     静态       |       块     |     无       |      块内，使用关键字static      |


##### 自动变量
> auto是存储类别说明符。（在C++中用法**完全不同**）属于自动存储类别的变量具有自动存储期，块作用域且无链接

- 默认情况，声明在块中或函数头中的任何变量都属于自动存储类别
- 为了更清楚表达你的意图，可以显式使用关键字auto。（例如，为了**表明有意覆盖一个外部变量定义**或者**强调不要把该变量改为其他类型**
- 例
```c
int m;    //m的作用域
scanf("%d",&m);
{
    int i;    //i和m的作用域
    for (i=m;i<n;i++)
        put("hi");
}
return m;  //m的作用域，i已经消失
```
- 如果这个变量仅供该块使用，那么在块中就近定义也很方便，可以在靠近使用的地方记录变量含义，另外这样的变量**只有在使用时才占内存**
- 如果内层块中声明的变量与外层块中的变量**同名**，内层块会**隐藏**外层块的定义。但是离开内层块后，外层块变量的作用域又回到了原来的作用域
- 没有花括号的块（循环块或if语句）
  - 循环体是整个循环块的子块，即使不使用花括号也是一个块
  - 循环头声明的变量会作用与循环体中。然而当循环体中也声明相同变量后，循环头中的变量会被循环体中的变量**从声明位置处隐藏**
- 自动变量的初始化
  - 自动变量不会初始化，除非显式初始化它

#### 寄存器变量
> 如果幸运的话，寄存器变量储存在CPU的寄存器中

- 使用存储类别说明符register声明寄存器变量
  ```
int main ()
{
    register int quick;
  ```
- 由于存储在寄存器而非内存，所以**无法获取**寄存器变量的**地址**
- 绝大数方面，寄存器变量和自动变量一样，为块作用域，无链接和自动存储期
- 编译器根据寄存器最快可用内存数量衡量请求，或者直接忽略请求
  - 这种情况下，寄存器变量就会变成普通的自动变量
  - 即便如此，依然不能对该变量使用地址运算符
- 在函数头使用关键字便可请求形参是寄存器变量 `void macho (register int n)` 
- **可声明为register的数据类型有限**，例如寄存器可能没有足够大的空间存储double类型的值

#### 块作用域的静态变量
> 这种变量和自动变量一样，具有块作用域，但是程序离开他们所在的函数后，这些变量不会消失（可以记录函数调用次数）

```
void trystat(void)
{
    int fade = 1;
    static int stay = 1;
    
    printf("fade = %d and stay = %d\\n", fade++, stay++);
}

```


- 在块中以static声明这种变量
- 这种变量只在编译时被初始化一次
- 如果未显式初始化静态变量，会被初始化为0
-  `static int stay=1` 
  - 实际上并不是该函数的一部分
  - 静态变量和外部变量在程序被载入内存时已经执行完毕。
  - 把这条声明放在函数中是为了告诉编译器只有该函数才能看到该变量
  -这条声明并未在允许时执行
- 不能在函数的形参中使用static
  - 这种存储类别被称为*内部静态存储类别*。这里的内部指**函数内部**，而非内部链接

#### 外部链接的静态变量
> 具有文件作用域，外部链接和静态存储期

- 变量的定义性声明放在所有函数的外面便创建了外部变量
- 为了指出函数使用外部变量，可以在函数中用关键字extern再次声明
- 如果一个源代码文件使用的外部变量定义在另一个源代码文件中，则必须使用extern在该文件中再次声明
- 声明已经定义的数组时可以**不用指明**数组**大小**，因为第一次声明已经提供了大小信息
- 如果在同文件内不加extern声明新的变量（如：int a），那么编译器将创建新的同名自动变量，且只在该函数内可见
  - 如果不得已使用同名变量，可以在局部变量声明中加上auto说明符明确表达意图
- 外部变量作用域：从**声明处**到文件结尾
----
##### 初始化外部变量
- 可以被显式初始化
- 如果为初始化外部变量，它们会被自动初始化为0（包括数组）
- **只能**用常量表达式初始化文件作用域变量
   ```
int x=10;    //可以
int y=3+20;    //可以
size_t z=sizeof(int);    //可以
int x2=2*x;    //不行，x是变量
   ```
   （只要不是变长数组，sizeof表达式可以被视为常量表达式）

##### 使用外部变量
```
#include <stdio.h>
int units = 0;         /* an external variable      */
void critic(void);
int main(void)
{
    extern int units;  /* an optional redeclaration */
    
    printf("How many pounds to a firkin of butter?\\n");
    scanf("%d", &units);
    while ( units != 56)
        critic();
    printf("You must have looked it up!\\n");
    
    return 0;
}

void critic(void)
{
    /* optional redeclaration omitted */
    printf("No luck, my friend. Try again.\\n");
    scanf("%d", &units);
}
```
- 循环结束时，main()也知道units的新值
- main()和critic()都可以通过标识符units访问**相同**变量

##### 外部名称
C99和C11标准都要求编译器识别局部标识符的前63个字符和外部标识符的前31个字符（外部变量需遵循局部环境规则，受限多）

##### 定义和声明
```
int tern =1; /*tern被定义*/
int main()
{
    extern int tern; /*使用在别处定义的tern*/
```
- tern被声明了两次
  - 第一次声明，为变量预留了存储空间，该声明构成了变量的定义（定义式声明）
  - 第二次声明只告诉编译器使用以前已经创建的tern变量，所以**不是定义**（引用式声明）
- 关键字extern表明该声明不是定义
- 不要用extern创建外部定义，只用来引用现有的外部定义
- 外部变量只能初始化一次，且必须在定义该变量时进行

#### 内部链接的静态变量
> 该存储类别的变量具有静态存储期，文件作用域和内部链接

- 用static定义的变量具有这种存储类别
- 这种变量在所有函数外部（同外部变量）
- 内部链接的静态变量只能用于同一文件中的函数（可以使用存储类别说明符extern）

#### 多文件
- 如果外部变量定义在一个文件中，那么其他文件在**使用**该变量前**必须声明**它
- 许多UNIX系统允许在多个文件中不使用extern关键字声明变量，前提是只有一个带初始化的声明
- 当内部链接变量和另一个外部链接变量名称相同，则以内部链接文件为准（个人不完全实验结论）

#### 存储类别说明符
1. auto
  - 明确**表达**使用与外部变量同名的局部变量的**意图**
2. register
  - 请求快速访问
  - **保护**变量地址不被获取
3. static
  - 用于文件作用域声明，作用域为该文件
  - 用于块作用域声明，作用域为块
4. extern
5. _Thread_local
6. typedef

#### 存储类别和函数
> 函数也有存储类别，可以是外部（默认）函数或静态函数，C99新增---内联函数

```
double gamma(double);  /*该函数默认为外部函数*/
static double beta(int ,int);
extern double delta(double, int);
```
同一个程序中，其他文件中函数可以调用gamma()和delta()，但是不能调用beta()
- 以**static**存储类别说明符创建的函数属于特定**模块私有**，避免命名冲突问题
- 用extern关键字声明定义其他文件中的函数，为了**表明**函数被定义在别处，除非加static默认都为extern


#### 随机数函数和静态变量

> ANSI C库提供了随机数函数rand( )生成随机数

- 生成的随机数在0~RAND_MAX之间
- RAND_MAX值定义在stdlib.h中，通常为INT_MAX


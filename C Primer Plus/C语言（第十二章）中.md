### 分配内存：malloc()和free()
#### malloc()
 > 该函数接受一个参数：所需的内存**字节数**，函数会找到空闲的内存块

- 分配内存，但不会为其赋名
- 返回动态分配内存块的首字节地址
- 如果分配失败，返回空指针
- 返回值通常被定义为char的指针
  > 从ANSI C标准开始，C使用了一种全新的类型：指向void的指针。相当于一个“通用指针”
  - 通常返回值会强制转换为匹配的类型
  - 应坚持使用强制转换

#### free()
> 通常，molloc()函数要有free()配套使用。free()函数参数是之前malloc()返回的地址，该函数释放之前分配的内存

- 不能释放其他方式分配的内存
- 如果忘记使用free()会导致内存泄露

#### calloc()
> 与malloc()类似，返回指向void的指针（ANSI后）

- 接收两个无符号整数作为参数
  1. 第一个是所需的存储单元数
  2. 第二个是存储单元的大小
- 它把所有块中的位置设置为0
- 用free()释放

### ANSI C类型限定符
 > C90新增两个属性：*恒常性*和*易变性*。这两个属性分别用 `const` 和 `volatile` 声明。C99新增了 `restrict` ，用于提高编译器优化。C11标准新增_Atomic。由stdatomic.h管理，支持**并发**程序设计，是可选项

- 幂等：可以在一条声明中多次使用同一个限定符，多余的将被忽略
  ```c
/*由幂等可编写如下代码*/
typedef const int zip;
const zip q=0;
  ```

#### const类型限定符
##### 在指针和形参声明中使用const
- const放在 `*` 左侧任意位置，限定了指向的数据不能改变
- const放在 `*` 右侧，限定了指针本身不能改变
- const常见用法是声明为函数形参的指针（保证数据不被更改）
   `void display(const int arr[], int limit);` 
  - 形参声明 `const int arr[]` 和`const int *arr`相同
##### 对全局使用const
> 使用全局变量是冒险的，因为这样暴露了数据，程序的任何部分都能修改数据。如果设置为const可以避免这样的危险

1. 在一个文件使用定义式声明其他文件中使用引用式声明（extern）
2. 把const变量放在一个头文件中，然后在其他文件中包含该文件
  - 必须在头文件使用static声明全局const变量。如果去掉那么在多个包含头文件的文件中都有相同标识符的定义式声明
  -这种方案相当于给每个文件提供了一个单独的数据副本，每个副本只对该文件可见
  - 缺点：数据是重复的，如果有一个很大的数组就不太合适了

##### volatile类型限定符
> volatile限定符告诉计算机，代理（而不是该变量所在的程序）可以改变该变量的值。通常用于硬件地址以及在其他程序或同时运行的线程中共享数据

  ```c
volatile int loc1;
/*是一个易变的位置*/
volatile int * ploc;
/*是指向易变位置的指针*/
  ```
- 如果没有声明volatile关键字，编译器会假定变量的值在使用过程中不变，然后尝试优化代码
- 可以用const 和volatile限定一个值
  > const把硬件时钟设置为程序不能更改的变量，但是可以通过代理改变，这时用volatile。
  
  ```
volatile const int loc;
const volatile int ploc;
/*循序不重要，只能在声明时使用*/
  ```

##### restrict类型限定符
> restrict关键字允许编译器优化某部分代码以更好地支持计算。它只能用于指针，表明该指针是访问数据对象的唯一且初始的方式

  ```
int ar[];
int * restrict restar = (int *) malloc(10*sizeof(int));
int *par =ar;

for ( n=0; n<10; n++)
{
    par[n]+=5;
    restar[n]+=5;
    ar[n]+=2;
    par[n]+=3;
    restar[n]+=3;
}
  ```

- 由于之前声明restar是访问指向数据块唯一且初始的方法，编译器可以把涉及restar的两条语句替换成下面的这条语句，效果相同
   `restar[n]+=8;` 
- 但是如果把与par相关的两条替换成 `par[n]+=8;` 将导致错误。因为在两次访问数据间，用ar改变了数据的值

- 如果未使用restrict关键字，编译器就必须假设最坏的情况。如果用了restrict关键字，编译器就可以选择捷径优化计算
- restrict限定符还可用于函数形参中的指针。这意味着编译器可以假定在函数体内其他标识符不会修改指针指向的数据

##### _Atomic类型限定符
> 并发程序设计把程序执行分成可以同时执行的多个线程。要通过各种宏函数来访问原子类型。当一个线程对原子类型的对象执行原子操作，其他线程不能访问该对象

```
_Atomic int hogs;
atomic_store(&hogs,12);    //stdatomic.h中的宏（赋值）
```
- 这里，在hogs中存储12是一个原子过程，其他线程不能访问hogs

##### 旧关键字的新位置
> C99允许把类型限定符和存储类别说明符static放在函数原型和函数头的形式参数的初始化方括号中。

- 
  ```c
void of (int * const a1; int * restrict a2);
void of (int a1 [const]; int a2 [restrict] );
  ```
  根据新标准，在声明函数形参时，指针表示法和数组表示法都可以使用这两个限定符

- 新标准为static引入了一种与以前用法不相关的新用法。新用法告诉编译器如何使用形式参数。
 \n`double stick(double ar [static 20] );` \n
static这种用法表明，函数调用中的实际参数应该是一个指向数组元素的**首元素**的指针，且该数组**至少**有20个元素\n
这种做法目的是让编译器使用这些信息优化函数代码


